/*
 * MIT License
 *
 * Copyright (c) 2017 Uber Node.js
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// @flow

import {Thrift} from 'thriftrw';
import {TypeConverter} from './types';
import prettier from 'prettier';
import path from 'path';

import type {Base} from 'bufrw';
import type {Struct, Field, Enum, Typedef, FunctionDefinition, Service} from 'thriftrw/ast';
const libDef = true;

const thriftOptions = {
  strict: false,
  allowFilesystemAccess: true,
  allowOptionalArguments: true
};

export class ThriftFileConverter {
  thriftPath: string;
  thrift: Thrift;
  types: TypeConverter;
  transformName: string => string;
  enumvalues: boolean;

  constructor(thriftPath: string, transformName: string => string, enumvalues) {
    this.thriftPath = path.resolve(thriftPath);
    this.thrift = new Thrift({...thriftOptions, entryPoint: thriftPath});
    this.transformName = transformName;
    this.types = new TypeConverter(transformName);
    this.enumvalues = enumvalues;
    this.exportPrefix = libDef ? '' : 'export ';
  }

  generateFlowFile = () =>
    prettier.format(
      [
        '// @flow',
        `// Generated by thrift2flow at ${new Date().toString()}\n// Source: ${this.thriftPath}`,
        this.generateImports(),
        ...this.thrift.asts[this.thrift.filename].definitions.map(this.convertDefinitionToCode),
        this.generateModules()
      ]
        .filter(Boolean)
        .join('\n\n'),
      {parser: 'flow'}
    );

  convertDefinitionToCode = (def: any) => {
    switch (def.type) {
      case 'Struct':
      case 'Exception':
        return this.generateStruct(def);
      case 'Union':
        return this.generateUnion(def);
      case 'Enum':
        return this.generateEnum(def);
      case 'Typedef':
        return this.generateTypedef(def);
      case 'Service':
        return this.generateService(def);
      default:
        console.warn(
          `${path.basename(this.thriftPath)}: Skipping ${def.type} ${def.id ? def.id.name : '?'}`
        );
        return null;
    }
  };

  generateService = (def: Service) =>
    `${this.exportPrefix}type ${this.transformName(def.id.name)} = {\n${def.functions
      .map(this.generateFunction)
      .join(',')}};`;

  generateFunction = (fn: FunctionDefinition) =>
    `${fn.id.name}: (${
      fn.fields.length ? this.generateStructContents([...fn.fields]) : ''
    }) => ${this.types.convert(fn.returns)}`;

  generateTypedef = (def: Typedef) =>
    `${this.exportPrefix}type ${this.transformName(def.id.name)} = ${this.types.convert(def.valueType)};`;

  generateEnumValues = (def: Enum) =>
    `${def.definitions.map((d, index) => `${d.value ? d.value.value : index}`).join(' | ')}`;

  generateEnumKeys = (def: Enum) => `{\n${def.definitions.map((d, index) => `"${d.id.name}": ${d.value ? d.value.value : index}`).join(',\n')}};`;

  generateEnum = (def: Enum) => {
    debugger;
    if (this.enumvalues) {
      return `${this.exportPrefix}type ${this.transformName(def.id.name)} = ${this.generateEnumValues(def)};
       ${this.exportPrefix}type ${this.transformName(def.id.name)}Keys = ${this.generateEnumKeys(def)};`;
    } else {
      return `${this.exportPrefix}type ${this.transformName(def.id.name)}Values = ${this.generateEnumValues(
        def
      )};
       ${this.exportPrefix}type ${this.transformName(def.id.name)} = ${this.generateEnumKeys(def)};`;
    }
  };

  generateStruct = (def: Struct) => {
    const content = `${this.exportPrefix}declare class ${this.transformName(def.id.name)} ${this.generateStructContents(def, def.id.name, def.fields)};`;
    return content;
  };

  generateStructContents = (def: Struct, name: string, fields: Object) =>
  {
    debugger;
    return `{
    constructor(args?: {
      ${Object.values(fields)
        .map(
          (f: Base) => {
            return `${f.name}${this.isOptional(f) ? '?' : ''}: ${this.types.convert(f.valueType)}${this.thrift.enums[f.valueType.name] ? 'Values' : ''};`;
          }
        )
        .join('\n')}
    }): ${this.transformName(name)};
    ${Object.values(fields)
      .map(
        (f: Base) => {
          return `${f.name}${this.isOptional(f) ? '?' : ''}: ${this.types.convert(f.valueType)}${this.thrift.enums[f.valueType.name] ? 'Values' : ''};`;
        }

      )
      .join('\n')}
  read: (protocol: mixed) => mixed,
  write: (protocol: mixed) => mixed
}
      `;
    }

  generateUnion = ({id: {name}, fields}: Struct) =>
    `${this.exportPrefix}type ${this.transformName(name)} = ${this.generateUnionContents(fields)};`;

  generateUnionContents = (fields: Object) => {
    if (!fields.length) {
      return '{||}';
    }
    return Object.values(fields)
      .map((f: Base) => {
        return `{|${f.name}: ${this.types.convert(f.valueType)}|}`;
      })
      .join(' | ');
  };

  isOptional = (field: Field) => field.optional;

  generateImports = () =>
    this.getImportAbsPaths()
      .filter(p => p !== this.thriftPath)
      .map(p =>
        path.join(
          path.dirname(path.relative(path.dirname(this.thriftPath), p)),
          path.basename(p, '.thrift')
        )
      )
      .map(p => (p.indexOf('/') === -1 ? `./${p}` : p))
      .map(relpath => `import * as ${path.basename(relpath)} from '${relpath}_types.js';`)
      .join('\n');

  getImportAbsPaths = () => Object.keys(this.thrift.idls).map(p => path.resolve(p));

  generateForStructs = (structs: Object) => {
    return Object.keys(structs).filter(f => f !== 'ThriftMessageEnvelopeExceptionType' && f !== 'ThriftMessageEnvelopeException').map(key => {
      return `  ${key}: typeof ${this.transformName(key)}`;
    });
  }

  generateForEnums = (structs: Object) => {
    return Object.keys(structs).filter(f => f !== 'ThriftMessageEnvelopeExceptionType' && f !== 'ThriftMessageEnvelopeException').map(key => {
      return `  ${key}: ${this.transformName(key)}`;
    });
  }

  generateModules = () => {
    debugger;
    const packPath = '\'@uber/mapstore-node/';
    const packSuffix = '_types\'';
    const modules = [
      ...this.generateForStructs(this.thrift.structs),
      ...this.generateForStructs(this.thrift.unions),
      ...this.generateForEnums(this.thrift.enums)
    ];
    const result = `
type ${this.transformName('Types')} = {
${modules.join(',\n')}
};

declare module ${packPath}${path.basename(this.thriftPath, '.thrift')}${packSuffix} {
  declare module.exports: ${this.transformName('Types')}
}

declare module ${packPath}browser-thrift/${path.basename(this.thriftPath, '.thrift')}${packSuffix} {
  declare module.exports: ${this.transformName('Types')}
}`;
    return result;
  };
}
